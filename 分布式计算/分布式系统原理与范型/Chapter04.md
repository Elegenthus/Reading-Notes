# Chapter 04 通信
## 4.1 基础知识
### 4.1.1 分层协议
开放式系统互连参考模型
#### 4.1.1.1 低层协议
* 物理层只负责传输位
* 数据链路层将若干位组成帧`frame`，并检查每一帧是否被接收方正确接收。-> 在每一帧开头和结尾放置特殊位模式，计算校验和。
* 网络层首要任务是如何选择最佳路径，应用最广泛的是无连接的IP协议，每个IP包彼此独立地发送到目的地
#### 4.1.1.2 传输协议
* 传输层将底层网络转换为可供应用程序开发人员使用的形式，提供可靠的连接服务
    * TCP 传输控制协议
    * UDP 通用数据报协议
    * RTP 实时传输协议
#### 4.1.1.3 高层协议
* 会话层：提供对话控制和同步功能
    * 对话控制：跟踪谈话的是哪一方
    * 同步功能：在传输过程中插入若干检验点，若传输崩溃只需要回退到最近的一个检测点
    * 很少用到，几乎不被提供支持
* 表示层：传输位的意义
* 应用层：现为所有由于各种原因不适合归于某个较低层中的应用程序和协议的容器

* 缺点：缺乏对应用程序、针对特定应用程序的协议以及通用协议的明确区分。
#### 4.1.1.4 中间件协议
中间件层代替会话层和表示层，其中包含有与应用程序无关的协议

### 4.1.2 通信类型
* 分类1
    * 持久通信
    * 瞬时通信
* 分类2
    * 异步通信
        * 发送方提交要传输的消息后立即往下执行
    * 同步通信
        * 发送方知道消息被接受后才往下执行
* 分类3
    * 不连续通信
        * 每个消息组成一个完整的信息单元
    * 流通信
        * 消息按照发送顺序相互关联

## 4.2 远程过程调用
* RPC(remote procedure call)：A机器调用B机器进程，A把参数作为信息传送给B，B执行完后把结果传回A。而编程人员看不到任何消息传递过程
### 4.2.1 基本的RPC操作
#### 4.2.1.1 常规过程调用
传值调用
引用调用
复制-还原调用
#### 4.2.1.2 客户与服务器存根程序
用户所涉及的操作知识通过执行普通的（本地）过程调用来访问远程服务，不需要直接调用send和receive。-> 效果是将客户过程对客户存根发出的本地调用转换成对服务器过程的本地调用，而客户和服务器都不会意识到有中间步骤的存在。
包含以下步骤：
* 客户以正常的方式调用客户存根
* 客户存根生成一个消息，然后调用本地操作系统
* 客户端操作系统将消息交给远程操作系统
* 远程操作系统将消息交给服务器存根
* 服务器存根将参数提取出来，然后调用服务器
* 服务器执行要求的操作，操作完成后将结果返回给服务器存根
* 服务器存根将结果打包成一个消息，然后调用本地操作系统
* 服务器操作系统将含有结果的消息发送回客户端操作系统
* 客户端操作系统将消息交给客户存根
* 客户存根将结果从消息中提取出来，返回给调用它的客户过程

### 4.2.2 参数传递
#### 4.2.2.1 传递值参数
* 参数列集：将参数打包进消息中
只将值传递，不会改变原参数的值
#### 4.2.2.2 传递引用参数
复制还原
作为输入参数时可以省略一个复制步骤
#### 4.2.2.3 参数说明和存根生成
PRC协议还应对消息格式、编码规则、信息交换规则进行规定。
接口定义语言实现接口，相同协议使用的存根用于不同过程中时，区别仅在接口。

### 4.2.3 异步RPC
* 客户向服务器发送请求，服务器收到后马上返回应答，服务器接受应答后可以接着自己的工作，服务器返回应答后再处理请求
* 延迟的同步RPC：两步异步RPC

### 4.2.4 示例 DCE RPC
#### 4.2.4.1 DEC概述
DCE->分布式计算环境
* 分布式文件服务：一种全球规模的文件系统，可以提供一种透明的访问方式，允许使用相同手段访问系统中任意文件
* 目录文件：用来跟踪系统中所有资源的位置
* 安全服务：允许对所有类型资源进行保护，可以将访问权提供给已经授权的用户
* 分布式时间服务：将位于不同机器上的时钟保持全局同步
#### 4.2.3.2 DCE RPC目标
* RPC系统使客户可以通过简单的本地过程调用来访问远程服务
* RPC系统负责向客户隐藏所有细节，并且也在某种程度上对服务器进行细节隐藏，处理客户端服务器绑定和双向信息传递
#### 4.2.4.3 编写客户程序和服务器程序
* IDL文件中最关键的是指定接口的全局唯一标识符，由uuidgen程序生成
* 编辑IDL文件，填入远程过程名和使用的参数
* 调用IDL编译器编译IDL文件，输出
    * 头文件
    * 客户存根
    * 服务器存根
* 在客户代码和服务器代码中将头文件include进去
* 编写客户和服务器代码
#### 4.2.4.4 将客户绑定到服务器
服务器定位
* 定位服务器所在机器
* 定位该机器上服务器，也就是进程，也就是端口
客户绑定到服务器过程
* 服务器在DCE守护程序注册端点
* 服务器向目录机器目标服务器注册服务
* 客户机向目录机器目标服务器查询服务器
* 客户机向DCE守护程序请求端点
* 客户机根据端点对服务器进行RPC调用
#### 4.2.4.5 执行RPC
常规方式透明执行

##4.3 面向消息的通信
### 4.3.1 面向消息的瞬时通信
#### 4.3.1.1 Berkeley 套接字
通过原语集可以使用传输层提供的全部（消息传递）协议
* bind：将本地地址与新创建的套接字相关联
* listen：只能在面向连接的通信中调用
* accept：阻塞调用者，直到有连接请求到达为止
#### 4.3.1.2 消息传递接口（MPI）
程序的硬件独立性的需要导致了消息传递方面标准的出台。
### 4.3.2 面向消息的持久通信
#### 4.3.2.1 消息队列模型
* 基本思想：应用程序可以通过在特定队列中插入消息进行通信。消息由一系列服务器转发最后到达目的地。即使接收方机器未处于运行状态，消息也能收到。
* 重要特征：只确保发送方发出消息最终能插入到接收方队列中，不保证消息到达的时间和一定会被读取
#### 4.3.2.2 消息队列系统一般体系结构
* 消息只能放入发送方的本地队列，也就是源队列
* 放入队列的消息将会包含对其要传输到的目的队列的说明
* 队列由队列管理器管理。
* 中继器：特殊的队列管理器，将输入的消息转发给其他的队列管理器
    * 优点
        * 有助于构建可拓展的消息队列系统
        * 允许对消息进行二次处理
        * 可用于多播目的-> 输入消息被简单地放入每一个发送队列
* 发布/订阅
#### 4.3.2.3 消息转换器
* 消息转换器：队列网络中进行消息格式转换的结点
* 核心：数据库
#### 4.3.2.4 消息队列系统说明
* 电子邮件系统：目的在于为最终用户提供直接支持
* 消息队列：目的要为进程间的持久通信提供支持。要提供可靠的消息传递、消息的优先级、日志功能、高效的多播、负载平衡、容错性等。

## 4.4 面向流的通信
讨论 如何为时间敏感的信息交换提供支持
### 4.4.1 为连续媒体提供支持
* 连续（表示）媒体：要了解不同数据项在时间上的联系。如音视频
* 离散（表示）媒体：数据项之间的时间联系对正确解释数据含义并不重要。如文本、静态图像、对象代码、可执行文件

* 传输模式
    * 异步传输模式：流中数据项逐个传播，对于时间没有限制 -> 离散数据流时的常见情况
    * 同步传输模式：数据流中每一个单元都定义了一个端到端最大延迟时间
    * 等时传输模式：数据单元必须按时传输
### 4.4.2 流与服务质量
* 服务质量QoS需求
    * 数据传输所要求的比特率
    * 创建会话的最大延时
    * 端到端的最大延时
    * 最大延时抖动
    * 最大往返延时
* 确保QoS
    * 快速转发
    * 确保型服务
    * 使用缓冲区减少抖动
    * 转发纠错：数据包内部缺失情况
    * 交错传输
### 4.4.3 流同步
* 同步是在建立流的数据单元这个层次上的。让两个流的数据单元保持同步，就可以让两个流同步
* 同步机制
    * 向应用程序提供接口，允许它更方便地对流和设备进行控制
    * MEPG -> motion picture experts group
    * 发送方同步：发送时合并多个流，并使用新的数据单元传输
    * 接收方同步

## 4.5 多播通信
### 4.5.1 应用层多播
* 应用层多播树
    * 链接树：计算数据包通过同一链接的次数
    * 伸缩/相对延时补偿：计算覆盖网络中两个结点之间的延时比，以及两个结点在底层网络中的延时
    * 树成本：与最小化总的链接代价有关，找到最小生成树
### 4.5.2 基于gossip的数据通信
#### 4.5.2.1 信息传播模型
* anti-entropy
    * push
    * pull
    * push-pull
* gossiping
    * 当遇到已感染节点，停止传播
* 两者结合
#### 4.5.2.2 删除数据
* 把数据项的删除记录为另一次更新，并保持这个删除记录？？
* 通过死亡证书完成
-> 别的结点可以看到这个数据项是被删除了，而不是被更新了

## 课后习题
* 假定客户通过异步RPC对服务器进行调用，随后等待服务器使用另一异步RPC返回结果。这种方法与客户执行常规的RPC有没有什么不同？如果使用的是同步RPC而不是异步RPC，情况又如何呢？
    * 异步RPC会向发送端返回一个已收到消息开始处理的回执，常规的不会。同步RPC调用和常规一样
* 请描述一下在客户和服务器进程间使用套接字时如何进行无连接通信
    * 服务器端程序
        * 创建一个新的通信端点socket
        * 将本地地址附加到套接字上bind
        * 等待接收数据recvfrom
        * 关闭套接字
    * 客户端
        * 创建一个新的通信端点socket
        * 发送数据sendto
        * 关闭套接字
* 面向连接
    * 服务器端程序
        * 创建套接字(socket);
        * 将套接字绑定到一个本地地址和端口上(bind);
        * 将套接字设为监听模式，准备接受客户请求(listen);
        * 等待客户请求到来；当请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字(accept);
        * 用返回的套接字和客户端进行通信(send/recv);
        * 返回，等待另一客户的请求;
        * 关闭套接字。
    * 客户端程序
        * 创建套接字(socket);
        * 向服务器发出连接请求(connect);
        * 和服务器端进行通信(send/recv);
        * 关闭套接字。
* 在本章我们讲过，为了自动启动一个进程以从输入队列中获取消息，常常要使用守护进程来监视输入队列。请给出一种不适用守护程序的实现方法。
    * 一个简单的实现方案是，每当接收端的进程将一条消息放进它的一个队列时，同时检查一下是否接收到了消息。
* 当一组计算机组成一个（逻辑上或者物理上）的环时，如何确保传输延迟不超过允许的最大端到端延迟时间？
    * 使用一个令牌在环上循环，只有持有环的计算机才能发送数据，并设置每个计算机持有令牌的时间不能超过最大端到端延迟时间
* 当在非结构化的点对点系统中查找文件时，限制查找与你有类似文件的结点可能会有用。请解释如何gossiping能有助于找到这些结点
    * gossiping时，节点之间相互交换信息，每一个节点都将获得另一个节点的全部信息。每当发现一个新的节点，都可以用与它在语义上相近的连接点来评估。比如，通过计算节点上的文件数量，那些语义上最邻近的节点将会被用来提交查询请求？？？